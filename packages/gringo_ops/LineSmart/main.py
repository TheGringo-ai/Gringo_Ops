# File: Agent/agent.py

# This file is part of the LineSmart submodule and is designed to work with the core Agent/agent.py

# --- Imports for secrets and OpenAI ---
from google.cloud import secretmanager
import openai

DEBUG_REWRITE_OUTPUT = True  # Set to False to disable writing invalid files to UnresolvedTasks

import ast
import os
import shutil

# --- Function to fetch OpenAI API key from Google Secret Manager ---
def get_openai_api_key():
    client = secretmanager.SecretManagerServiceClient()
    secret_name = "projects/487771372565/secrets/openai-api-key/versions/latest"
    response = client.access_secret_version(request={"name": secret_name})
    return response.payload.data.decode("UTF-8")

# Set OpenAI API key globally
openai.api_key = get_openai_api_key()

def is_valid_python_code(code):

    """Placeholder docstring for is_valid_python_code."""    try:
        ast.parse(code)
        return True
    except SyntaxError:
        return False

def write_rewritten_file(filename, content, log_content=None):
    """
    Handles writing rewritten Python files with validation and output routing.
    
    Args:
        filename (str): The name of the rewritten file.
        content (str): The rewritten Python code.
        log_content (str, optional): Log content for invalid files.
    """
    # Determine if file is a Python file
    is_py_file = filename.endswith('.py')
    
    # Validate Python code if it is a .py file
    if is_py_file:
        valid = is_valid_python_code(content)
    else:
        valid = True  # Non-python files are considered valid by default
    
    # Directories
    completed_dir = os.path.join('CompletedTasks')
    unresolved_dir = os.path.join('UnresolvedTasks')
    
    # Ensure directories exist
    if not os.path.exists(completed_dir):
        os.makedirs(completed_dir)
    if not os.path.exists(unresolved_dir):
        os.makedirs(unresolved_dir)
    
    if is_py_file and valid:
        # Write valid Python file to CompletedTasks/
        dest_path = os.path.join(completed_dir, filename)
        with open(dest_path, 'w', encoding='utf-8') as f:
            f.write(content)
        print(f"✅ Valid file written: {filename}")
    elif is_py_file and not valid:
        # Write invalid Python file and log to UnresolvedTasks/ if debug enabled
        if DEBUG_REWRITE_OUTPUT:
            invalid_filename = filename[:-3] + '_invalid.py'
            dest_path = os.path.join(unresolved_dir, invalid_filename)
            with open(dest_path, 'w', encoding='utf-8') as f:
                f.write(content)
            if log_content:
                log_filename = invalid_filename[:-3] + '.log'
                log_path = os.path.join(unresolved_dir, log_filename)
                with open(log_path, 'w', encoding='utf-8') as log_file:
                    log_file.write(log_content)
            print(f"❌ Invalid rewrite saved to UnresolvedTasks: {invalid_filename}")
        # Do not write invalid files anywhere else
    else:
        # For non-python files, write normally to CompletedTasks/
        dest_path = os.path.join(completed_dir, filename)
        with open(dest_path, 'w', encoding='utf-8') as f:
            f.write(content)
        print(f"✅ Valid file written: {filename}")

# Example usage in the agent rewrite pipeline:
# rewritten_code = "..."  # code generated by AI
# filename = "example.py"
# log = "SyntaxError: invalid syntax on line 3"
# write_rewritten_file(filename, rewritten_code, log_content=log)

from pathlib import Path

def scan_and_clean(cli_args):
    """
    Scans and processes all .py files recursively within the entire GringoOps folder,
    excluding files specified in cli_args.
    """
    ROOT_DIR = Path(__file__).resolve().parents[2]
    py_files = [f for f in ROOT_DIR.rglob("*.py") if f.is_file() and f.name not in cli_args]
    for py_file in py_files:
        # Process each Python file as needed
        print(f"Processing file: {py_file}")

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Run cleanup for LineSmart or custom subfolder.")
    parser.add_argument('--exclude', nargs='*', default=[], help="List of filenames to exclude from scan.")
    args = parser.parse_args()

    scan_and_clean(args.exclude)