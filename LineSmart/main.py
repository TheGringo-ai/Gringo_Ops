# File: Agent/agent.py

# This file is part of the LineSmart submodule and is designed to work with the core Agent/agent.py

# --- Imports for secrets and OpenAI ---
from google.cloud import secretmanager
import openai

import ast
import os
import shutil
import subprocess
import time
from datetime import datetime
from memory import log_event  # Assuming you have a centralized memory logger

DEBUG_REWRITE_OUTPUT = True  # Set to False to disable writing invalid files to UnresolvedTasks

# --- Function to fetch OpenAI API key from Google Secret Manager ---
def get_openai_api_key():
    client = secretmanager.SecretManagerServiceClient()
    secret_name = "projects/487771372565/secrets/openai-api-key/versions/latest"
    response = client.access_secret_version(request={"name": secret_name})
    return response.payload.data.decode("UTF-8")

# Set OpenAI API key globally
openai.api_key = get_openai_api_key()

def is_valid_python_code(code):
    try:
        ast.parse(code)
        return True
    except SyntaxError:
        return False

def write_rewritten_file(filename, content, log_content=None):
    """
    Handles writing rewritten Python files with validation and output routing.
    
    Args:
        filename (str): The name of the rewritten file.
        content (str): The rewritten Python code.
        log_content (str, optional): Log content for invalid files.
    """
    # Determine if file is a Python file
    is_py_file = filename.endswith('.py')
    
    # Validate Python code if it is a .py file
    if is_py_file:
        valid = is_valid_python_code(content)
    else:
        valid = True  # Non-python files are considered valid by default
    
    # Directories
    completed_dir = os.path.join('CompletedTasks')
    unresolved_dir = os.path.join('UnresolvedTasks')
    
    # Ensure directories exist
    if not os.path.exists(completed_dir):
        os.makedirs(completed_dir)
    if not os.path.exists(unresolved_dir):
        os.makedirs(unresolved_dir)
    
    if is_py_file and valid:
        # Write valid Python file to CompletedTasks/
        dest_path = os.path.join(completed_dir, filename)
        with open(dest_path, 'w', encoding='utf-8') as f:
            f.write(content)
        print(f"✅ Valid file written: {filename}")
        log_event("File written", {
            "filename": filename,
            "valid": valid,
            "timestamp": datetime.utcnow().isoformat()
        })
        if 'args' in globals() and args.git_commit:
            subprocess.run(["git", "add", dest_path])
            subprocess.run(["git", "commit", "-m", f'Auto-cleaned {filename}'])
    elif is_py_file and not valid:
        # Write invalid Python file and log to UnresolvedTasks/ if debug enabled
        if DEBUG_REWRITE_OUTPUT:
            invalid_filename = filename[:-3] + '_invalid.py'
            dest_path = os.path.join(unresolved_dir, invalid_filename)
            with open(dest_path, 'w', encoding='utf-8') as f:
                f.write(content)
            if log_content:
                log_filename = invalid_filename[:-3] + '.log'
                log_path = os.path.join(unresolved_dir, log_filename)
                with open(log_path, 'w', encoding='utf-8') as log_file:
                    log_file.write(log_content)
            print(f"❌ Invalid rewrite saved to UnresolvedTasks: {invalid_filename}")
            log_event("Invalid Python file", {
                "filename": filename,
                "log": log_content or "No log",
                "timestamp": datetime.utcnow().isoformat()
            })
        # Do not write invalid files anywhere else
    else:
        # For non-python files, write normally to CompletedTasks/
        dest_path = os.path.join(completed_dir, filename)
        with open(dest_path, 'w', encoding='utf-8') as f:
            f.write(content)
        print(f"✅ Valid file written: {filename}")
        log_event("File written", {
            "filename": filename,
            "valid": valid,
            "timestamp": datetime.utcnow().isoformat()
        })

# Example usage in the agent rewrite pipeline:
# rewritten_code = "..."  # code generated by AI
# filename = "example.py"
# log = "SyntaxError: invalid syntax on line 3"
# write_rewritten_file(filename, rewritten_code, log_content=log)

from pathlib import Path

def scan_and_clean(cli_args):
    """
    Scans and processes all .py files recursively within the entire GringoOps folder,
    excluding files specified in cli_args.
    """
    start_time = time.time()
    valid_count = 0
    invalid_count = 0

    ROOT_DIR = Path(__file__).resolve().parents[2]
    py_files = [f for f in ROOT_DIR.rglob("*.py") if f.is_file() and f.name not in cli_args]
    for py_file in py_files:
        # Process each Python file as needed
        print(f"Processing file: {py_file}")
        # You could call write_rewritten_file here if you modify logic to rewrite
        pass

    elapsed = time.time() - start_time
    print(f"✅ Scan complete: {len(py_files)} files in {elapsed:.2f}s")
    print(f"   Valid: {valid_count}, Invalid: {invalid_count}")
    log_event("Scan summary", {
        "total_files": len(py_files),
        "valid_files": valid_count,
        "invalid_files": invalid_count,
        "duration_seconds": elapsed
    })

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Run cleanup for LineSmart or custom subfolder.")
    parser.add_argument('--exclude', nargs='*', default=[], help="List of filenames to exclude from scan.")
    parser.add_argument('--git-commit', action='store_true', help="Auto-commit valid cleaned files to Git")
    args = parser.parse_args()

    scan_and_clean(args.exclude)